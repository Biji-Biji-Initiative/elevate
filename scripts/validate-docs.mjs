#!/usr/bin/env node
/**
 * Documentation Validation Script
 * Validates markdown docs follow organization standards
 */

import { readFileSync, existsSync } from 'fs'
import { join, dirname, relative } from 'path'
import { fileURLToPath } from 'url'

import { glob } from 'glob'

const __dirname = dirname(fileURLToPath(import.meta.url))
const rootDir = join(__dirname, '..')

let hasErrors = false

/**
 * Colors for output
 */
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
}

function log(color, icon, message) {
  console.log(`${colors[color]}${icon} ${message}${colors.reset}`)
}

function logError(message) {
  log('red', '❌', message)
}

function logSuccess(message) {
  log('green', '✅', message)
}

function logWarning(message) {
  log('yellow', '⚠️ ', message)
}

function logInfo(message) {
  log('blue', 'ℹ️ ', message)
}

/**
 * Parse front-matter from markdown content
 */
function parseFrontMatter(content) {
  const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/)
  if (!frontMatterMatch) {
    return null
  }

  const yamlContent = frontMatterMatch[1]
  const frontMatter = {}

  for (const line of yamlContent.split('\n')) {
    const match = line.match(/^(\w+):\s*(.*)$/)
    if (match) {
      const [, key, value] = match
      if (value.startsWith('[') && value.endsWith(']')) {
        // Parse array values
        frontMatter[key] = value
          .slice(1, -1)
          .split(',')
          .map((s) => s.trim().replace(/^["']|["']$/g, ''))
      } else {
        frontMatter[key] = value.replace(/^["']|["']$/g, '')
      }
    }
  }

  return frontMatter
}

/**
 * Validate a single markdown file
 */
function validateDocFile(filePath) {
  try {
    const content = readFileSync(filePath, 'utf-8')
    const relativePath = relative(rootDir, filePath)
    const violations = []

    // Check front-matter for key docs
    const isKeyDoc =
      relativePath.includes('docs/') &&
      (relativePath.includes('BUILDING') ||
        relativePath.includes('DATABASE') ||
        relativePath.includes('policies') ||
        relativePath.includes('roles-permissions') ||
        relativePath.includes('VALIDATION_SYSTEMS'))

    // Check for proper heading structure (only warn for key docs)
    const lines = content.split('\n')
    const firstHeading = lines.find((line) => line.startsWith('#'))

    // For generated API reports (*.api.md), skip heading enforcement
    const isApiReport = /\.api\.md$/.test(relativePath)

    if (!firstHeading && !isApiReport) {
      violations.push('Missing main heading (## Title)')
    } else if (!firstHeading?.startsWith('##') && isKeyDoc && !isApiReport) {
      violations.push('Main heading should be H2 (## Title)')
    }

    if (isKeyDoc) {
      const frontMatter = parseFrontMatter(content)
      if (!frontMatter) {
        violations.push('Missing front-matter (required for key docs)')
      } else {
        const requiredFields = ['title', 'owner', 'status', 'last_reviewed']
        for (const field of requiredFields) {
          if (!frontMatter[field]) {
            violations.push(`Missing required front-matter field: ${field}`)
          }
        }

        if (
          frontMatter.status &&
          !['draft', 'active', 'deprecated', 'archived'].includes(
            frontMatter.status,
          )
        ) {
          violations.push(
            'Invalid status in front-matter (must be: draft, active, deprecated, archived)',
          )
        }
      }
    }

    // Check for generated doc banners
    if (
      relativePath.includes('api-reports/') &&
      !content.toLowerCase().includes('generated by [api extractor]')
    ) {
      violations.push('API report missing generated banner')
    }

    // Check for proper file naming (only warn for new docs)
    const fileName = relativePath.split('/').pop()
    if ((fileName.includes(' ') || fileName.includes('_')) && isKeyDoc) {
      violations.push(
        'File should use kebab-case naming (no spaces or underscores)',
      )
    }

    if (violations.length > 0) {
      hasErrors = true
      logError(`Found violations in ${relativePath}:`)
      violations.forEach((violation) => {
        console.log(`  • ${violation}`)
      })
      return false
    }

    return true
  } catch (error) {
    hasErrors = true
    logError(`Failed to validate ${filePath}: ${error.message}`)
    return false
  }
}

/**
 * Main validation function
 */
async function main() {
  logInfo('Validating documentation standards...\n')

  // Find all markdown files
  const markdownFiles = await glob('**/*.md', {
    cwd: rootDir,
    absolute: true,
    ignore: [
      '**/node_modules/**',
      '**/dist/**',
      '**/build/**',
      '**/.next/**',
      '**/.turbo/**',
      '**/coverage/**',
      '**/archive/**',
    ],
  })

  if (markdownFiles.length === 0) {
    logError('No markdown files found to validate')
    process.exit(1)
  }

  logInfo(`Checking ${markdownFiles.length} markdown files...`)

  let validFiles = 0
  let totalFiles = 0

  // Validate each file
  for (const filePath of markdownFiles) {
    totalFiles++
    if (validateDocFile(filePath)) {
      validFiles++
    }
  }

  // Summary
  console.log()
  console.log('='.repeat(60))
  console.log('Documentation Validation Summary')
  console.log('='.repeat(60))

  if (hasErrors) {
    logError(
      `${
        totalFiles - validFiles
      } files with violations out of ${totalFiles} total`,
    )
    console.log()
    console.log('Common fixes:')
    console.log('• Add front-matter with title, owner, status, last_reviewed')
    console.log('• Use H2 (##) for main headings')
    console.log('• Use kebab-case for filenames')
    console.log('• Add generated banners to API reports')
    process.exit(1)
  } else {
    logSuccess(`All ${totalFiles} files meet documentation standards!`)
    console.log('✓ Proper heading structure')
    console.log('✓ Front-matter present where required')
    console.log('✓ Consistent file naming')
    console.log('✓ Generated docs properly marked')
    process.exit(0)
  }
}

main().catch((err) => {
  logError(`Validation failed: ${err.message}`)
  console.error(err.stack)
  process.exit(1)
})
